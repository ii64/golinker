package elf

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path"
	"strings"

	"github.com/ii64/golinker/lib/disasm2"
	"github.com/ii64/golinker/lib/hdr"
	"github.com/ii64/golinker/lib/util"
)

var fileDiscHeader = `// +build !noasm !appengine
// Code generated by golinker, DO NOT EDIT.
// Command: ` + strings.ReplaceAll(strings.Join(os.Args, " "), "\n", "") + `
`

var fileHeader = fileDiscHeader + `
#include "go_asm.h"
#include "funcdata.h"
#include "textflag.h"

`

func (st *LinkState) Generate() (err error) {

	basename, _ := st.cfg.GetStubFileBasename()

	asmFileName := path.Join(st.cfg.OutputDir, fmt.Sprintf("%s_%s.s", basename, st.Arch))
	offFileName := path.Join(st.cfg.OutputDir, fmt.Sprintf("%s_%s.go", basename, st.Arch))
	extSymStubFileName := path.Join(st.cfg.OutputDir, fmt.Sprintf("%s_external_%s.s", basename, st.Arch))

	// !! overwrite existing generated files

	var asmFile *os.File
	asmFile, err = os.Create(asmFileName)
	if err != nil {
		return
	}
	defer asmFile.Close()

	var offFile *os.File
	offFile, err = os.Create(offFileName)
	if err != nil {
		return
	}
	defer offFile.Close()

	if st.cfg.GenExternalSymStub {
		var extSymStubFile *os.File
		extSymStubFile, err = os.Create(extSymStubFileName)
		if err != nil {
			return
		}
		defer extSymStubFile.Close()
		err = st.writeAsmExtSymStub(extSymStubFile)
		if err != nil {
			return
		}
	}

	switch st.Arch {
	case "amd64":
		err = st.writeAsmAMD64(asmFile)
		if err != nil {
			return
		}
		err = st.writeOffAMD64(offFile)
		if err != nil {
			return
		}
		return
	}
	err = fmt.Errorf("writer unimplemented")
	return
}

func (st *LinkState) writeAsmExtSymStub(writer io.Writer) (err error) {
	bio := bufio.NewWriter(writer)
	bio.WriteString(fileHeader)

	for _, extSymOff := range st.sExtSymOffOrder {
		extSymName := st.sExtSym[extSymOff]

		bio.WriteString(fmt.Sprintf("// emu off: %x (%d)\n", extSymOff, extSymOff))
		bio.WriteString(fmt.Sprintf(
			"TEXT %s(SB), NOSPLIT, $0\n", extSymName))
		bio.WriteString("\tNO_LOCAL_POINTERS\n")
		bio.WriteRune('\n')

		bio.WriteString("\tRET\n")

		bio.WriteRune('\n')
	}

	err = bio.Flush()
	return
}

func (st *LinkState) writeOffAMD64(writer io.Writer) (err error) {
	bio := bufio.NewWriter(writer)

	defer func() {
		err = bio.Flush()
	}()

	bio.WriteString(fileDiscHeader)
	bio.WriteString(fmt.Sprintf("package %s\n\n", st.hdr.PackageName()))

	bio.WriteString("//go:nosplit\n")
	bio.WriteString("//go:noescape\n")
	bio.WriteString("//goland:noinspection ALL\n")
	bio.WriteString(fmt.Sprintf("func %s() uintptr\n", st.cfg.NativeEntryName))

	bio.WriteString("\n")

	var subrVar []string
	var stackVar []string

	var chkVarName = map[string]uint64{}

	// subr
	if len(st.sFnOrder) > 1 {
		bio.WriteString("var (\n")
		for _, fnOff := range st.sFnOrder[1:] {
			if !st.needToWriteOffsetAndStackInfoAMD64(fnOff) {
				continue
			}

			fnName := st.sFnName[fnOff]
			var varName string
			cnt, exist := chkVarName[fnName]
			if exist {
				varName = fmt.Sprintf("__subr_%s_%d", fnName, cnt)
				chkVarName[fnName]++
			} else {
				varName = fmt.Sprintf("__subr_%s", fnName)
				chkVarName[fnName]++
			}

			subrVar = append(subrVar, varName)
			bio.WriteString(fmt.Sprintf("\t%s = %s() + %d\n", varName, st.cfg.NativeEntryName, fnOff))
		}
		bio.WriteString(")\n\n")
		defer func() {
			bio.WriteString("var (\n")
			for _, subr := range subrVar {
				bio.WriteString(fmt.Sprintf("\t_ = %s\n", subr))
			}
			bio.WriteString(")\n")
		}()
	}

	chkVarName = map[string]uint64{}

	// stack size
	if len(st.sFnOrder) > 1 {
		bio.WriteString("const (\n")
		for _, fnOff := range st.sFnOrder[1:] {
			if !st.needToWriteOffsetAndStackInfoAMD64(fnOff) {
				continue
			}

			fnStackSz := st.sFnStackSz[fnOff]
			fnName := st.sFnName[fnOff]
			var varName string
			cnt, exist := chkVarName[fnName]
			if exist && cnt > 0 {
				varName = fmt.Sprintf("__stack_%s_%d", fnName, cnt)
				chkVarName[fnName]++
			} else {
				varName = fmt.Sprintf("__stack_%s", fnName)
				chkVarName[fnName]++
			}

			stackVar = append(stackVar, varName)
			bio.WriteString(fmt.Sprintf("\t%s = %d\n", varName, fnStackSz))
		}
		bio.WriteString(")\n\n")
		defer func() {
			bio.WriteString("const (\n")
			for _, stk := range stackVar {
				bio.WriteString(fmt.Sprintf("\t_ = %s\n", stk))
			}
			bio.WriteString(")\n")
		}()
	}

	return
}

func (st *LinkState) needToWriteOffsetAndStackInfoAMD64(off uint64) bool {
	fnName := st.sFnName[off]
	if strings.Contains(fnName, fmt.Sprintf("%s_aligner",
		st.cfg.NativeEntryName)) {
		return false
	}
	return true
}

func (st *LinkState) writeAsmAMD64(writer io.Writer) (err error) {
	bio := bufio.NewWriter(writer)
	_, err = bio.WriteString(fileHeader)
	if err != nil {
		return
	}

	// !! ----- write program ------

	var sum uint64
	for i, addr := range st.sInsList {
		if i+1 < len(st.sInsList) {
			sum += st.sInsList[i+1] - addr
		}
	}
	bio.WriteString(fmt.Sprintf("// native size: %d\n", sum))

	bio.WriteRune('\n')

	_, err = bio.WriteString(fmt.Sprintf(
		"TEXT ·%s(SB), NOSPLIT, $0\n", st.cfg.NativeEntryName))
	if err != nil {
		return
	}
	_, err = bio.WriteString("\tNO_LOCAL_POINTERS\n")

	// header flush.
	err = bio.Flush()
	if err != nil {
		return
	}

	// write data GLOBL decl
	// tbd...

	// write instructions
	for _, addr := range st.sInsList {
		comment, exist := st.sComment[addr]
		label, exist2 := st.sLabelSym[addr]
		if exist { // write comment
			if !exist2 { // if the comment is on a label
				bio.WriteRune('\t')
			}
			bio.WriteString("// ")
			bio.WriteString(comment)
			bio.WriteRune('\n')
		}
		if exist2 { // write label
			bio.WriteRune('\n')
			bio.WriteString(label)
			bio.WriteString(":\n")
		}

		// write instruction
		asmfmt, exist3 := st.sIns[addr]
		if exist3 {
			bio.WriteRune('\t')
			bio.WriteString(asmfmt.String())
			bio.WriteRune('\n')
		}
	}
	// write remaining program data
	data := st.getRemainingProgData()
	bio.WriteString(fmt.Sprintf("\n// data size: %d\n", len(data)))
	for _, b := range util.Chunk(data, 16) {
		dts := disasm2.ArchAMD64.EncodeRawBytes(b)
		bio.WriteRune('\t')
		for i, dt := range dts {
			bio.WriteString(dt.Asm)
			if i+1 < len(dts) {
				bio.WriteString("; ")
			}
		}
		bio.WriteRune('\n')
	}

	// !! ----- write stub ------

	bio.WriteString("\n\n")

	bio.WriteString("\n\n")

	for _, fnOff := range st.sFnOrder[1:] {
		err = st.getAsmFuncStubAMD64(fnOff, bio)
		if err == errSkipAsmStub {
			continue
		} else if err != nil {
			return
		}
		bio.WriteRune('\n')
	}

	// !! ----- flush ------

	bio.WriteString("\n")
	// last flush
	err = bio.Flush()
	return
}

var errSkipAsmStub = fmt.Errorf("skip asm stub")

func (st *LinkState) getAsmFuncStubAMD64(fnOff uint64, bio *bufio.Writer) (err error) {
	fn, exist3 := st.sFnHdr[fnOff]
	if !exist3 {
		// err = fmt.Errorf("func header not implemented: %s", fnName)
		err = errSkipAsmStub
		return
	}

	fnName, exist := st.sFnName[fnOff]
	fnStackSz, exist2 := st.sFnStackSz[fnOff]
	var fnArgRetSz uint64
	if !exist {
		err = fmt.Errorf("func name is not present")
		return
	}
	if !exist2 {
		err = fmt.Errorf("func stack is not present")
		return
	}

	var args []hdr.Var
	var rets []hdr.Var
	args, rets, fnArgRetSz = st.hdr.GetFuncArgRetSize(fn)

	// write comment if available
	if cmt := fn.Doc.Text(); cmt != "" {
		cmt = strings.Trim(cmt, "\n")
		bio.WriteString(fmt.Sprintf("// %s", strings.Replace(cmt, "\n", "\n// ", -1)))
		bio.WriteRune('\n')
	}
	// func asm decl
	_, err = bio.WriteString(fmt.Sprintf(
		"TEXT ·%s(SB), NOSPLIT | NOFRAME, $0 - %d\n",
		fnName, fnArgRetSz))
	if err != nil {
		return
	}
	_, err = bio.WriteString("\tNO_LOCAL_POINTERS\n\n")
	if err != nil {
		return
	}

	// check stack, if it below desired address, call morestack.
	bio.WriteString("_entry:\n")
	bio.WriteString("\tMOVQ (TLS), R14\n")
	bio.WriteString(fmt.Sprintf("\tLEAQ %d(SP), R12\n", -int64(fnStackSz)))
	bio.WriteString("\tJBE _more_stack\n\n")

	// --- stack to regs ---
	argsysv := []string{"DI", "SI", "DX", "CX", "R8", "R9"}
	retsysv := []string{"AX"}
	// todo: handle floating point register

	bio.WriteString(fmt.Sprintf("_%s:\n", fnName))

	mnFromSz := func(sz uint64) string {
		switch sz {
		case 4:
			return "MOVL"
		case 2:
			return "MOVW"
		case 1:
			return "MOVB"
		}
		return "MOVQ"
	}

	for i := range args {
		argname := args[i]
		if i >= len(argsysv) {
			err = fmt.Errorf("register not available for arg: %q", argname)
			return
		}
		v := args[i]
		regDst := argsysv[i]
		// write arg
		mnem := mnFromSz(v.Size)

		bio.WriteString(fmt.Sprintf("\t%s %s+%d(FP), %s\n",
			mnem, v.Name, v.Offset,
			regDst))
	}
	if len(rets) < 1 {
		bio.WriteString(fmt.Sprintf("\tLEAQ ·%s+%d(SB), AX\n",
			st.cfg.NativeEntryName, fnOff,
		))
		bio.WriteString("\tJMP AX\n")
	} else {
		bio.WriteString(fmt.Sprintf("\tCALL ·%s+%d(SB)\n",
			st.cfg.NativeEntryName, fnOff,
		))
		for i := range rets {
			v := rets[i]
			if i >= len(retsysv) {
				err = fmt.Errorf("register not available for ret: %q", v.Name)
				return
			}
			regSrc := retsysv[i]
			// write ret
			mnem := mnFromSz(v.Size)
			bio.WriteString(fmt.Sprintf("\t%s %s, %s+%d(FP)\n",
				mnem,
				regSrc,
				v.Name, v.Offset))
		}
		bio.WriteString("\tRET\n")
	}

	bio.WriteRune('\n')

	// more stack
	bio.WriteString("_more_stack:\n")
	bio.WriteString("\tCALL runtime·morestack_noctxt<>(SB)\n")
	bio.WriteString("\tJMP _entry\n\n")

	err = bio.Flush()
	return
}
