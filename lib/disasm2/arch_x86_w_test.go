package disasm2

import (
	"encoding/binary"
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestStackSizeCountAMD64(t *testing.T) {
	type test struct {
		exp uint64
		b   []byte
	}
	prog := []test{
		// sub    $0x10,%rsp
		{0x18, []byte{0x48, 0x83, 0xec, 0x18}},
		// lea    0x8(%rsp),%rbp
		{0x8, []byte{0x48, 0x8d, 0x6c, 0x24, 0x08}},

		// sub    $0x10,%rsp
		// lea    0x8(%rsp),%rbp
		{0x18, []byte{0x48, 0x83, 0xec, 0x18,
			0x48, 0x8d, 0x6c, 0x24, 0x08}},
	}
	for _, tc := range prog {
		insts, err := ArchAMD64.DecodeBlock(tc.b, 0x0)
		assert.NoError(t, err)

		fs := ArchAMD64.GoSyntaxBlock(insts, 0x0, nil, nil)
		for _, f := range fs {
			fmt.Println(f)
		}
		fmt.Println("----------")

		act := ArchAMD64.StackSize(insts)
		assert.Equal(t, tc.exp, act)
	}
}

func TestDisasmBlockAMD64(t *testing.T) {
	prog := [][]byte{
		// subr
		{0x55, 0x48, 0x89, 0xe5, 0xb8, 0x47, 0xf4, 0x10, 0x0, 0x5d, 0xc3},

		// subr2
		{0x55, 0x48, 0x89, 0xe5, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x5, 0x8e, 0xe8, 0x21, 0x0, 0x5d, 0xc3},
	}

	for _, code := range prog {
		insts, err := ArchAMD64.DecodeBlock(code, 0x0)
		assert.NoError(t, err)

		var att []string
		for _, inst := range insts {
			att = append(att, inst.Mnemonic+" "+inst.OpStr)
		}

		fs := ArchAMD64.GoSyntaxBlock(insts, 0x0, func(addr uint64) (name string, base uint64) {
			if addr == 0x9 {
				return "anotherSubr", addr
			}
			return "", 0
		}, nil)
		var fss []string
		for _, t := range fs {
			fss = append(fss, t.String())
		}

		stackSize := ArchAMD64.StackSize(insts)

		fmt.Printf("------- stack size: %d\n%s\n----------\n%s\n",
			stackSize,
			strings.Join(att, "\n"),
			strings.Join(fss, "\n"))
	}

}

func TestDisasmAMD64(t *testing.T) {
	type tc struct {
		exp  string
		code []byte
	}
	prog := []tc{
		{"VZEROUPPER", []byte{0xc5, 0xf8, 0x77}},

		{"PUSHQ R12", []byte{0x41, 0x54}},
		{"POPQ R12", []byte{0x41, 0x5c}},

		{"MOVQ $0x1, AX", []byte{0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00}},

		{"CMPQ 0x10(R14), R12", []byte{0x4d, 0x39, 0x66, 0x10}},
		{"CMPQ R12, 0x10(R14)", []byte{0x4d, 0x3b, 0x66, 0x10}},

		// MOVQ $2222, 0x10(FP)
		{"MOVQ $0x8ae, 0x10(SP)", []byte{0x48, 0xc7, 0x44, 0x24, 0x10, 0xae, 0x08, 0x00, 0x00}},

		// movq   $0x4d2,0x10(%rsp)
		{"MOVQ $0x4d2, 0x10(SP)", []byte{0x48, 0xc7, 0x44, 0x24, 0x10, 0xd2, 0x04, 0x00, 0x00}},
		// movl   $0x4d2,0x10(%rsp)
		{"MOVL $0x4d2, 0x10(SP)", []byte{0xc7, 0x44, 0x24, 0x10, 0xd2, 0x04, 0x00, 0x00}},
		// movw   $0x4d2,0x10(%rsp)
		{"MOVW $0x4d2, 0x10(SP)", []byte{0x66, 0xc7, 0x44, 0x24, 0x10, 0xd2, 0x04}},
		// movb   $0xd2,0x10(%rsp)
		{"MOVB $0xd2, 0x10(SP)", []byte{0xc6, 0x44, 0x24, 0x10, 0xd2}},

		// mov    $0xc,%rax
		{"MOVQ $0xc, AX", []byte{0x48, 0xc7, 0xc0, 0x0c, 0x00, 0x00, 0x00}},
		// mov    $0xc,%eax
		{"MOVL $0xc, AX", []byte{0xb8, 0x0c, 0x00, 0x00, 0x00}},
		// mov    $0xc,%ax
		{"MOVW $0xc, AX", []byte{0x66, 0xb8, 0x0c, 0x00}},
		// mov    $0xc,%al
		{"MOVB $0xc, AX", []byte{0xb0, 0x0c}},

		// lea    (%rbx,%rax,1),%rdx
		{"LEAQ (BX)(AX*1), DX", []byte{0x48, 0x8d, 0x14, 0x03}},
		// lea    (%rdx,%rbx,1),%rax
		{"LEAQ (DX)(BX*1), AX", []byte{0x48, 0x8d, 0x04, 0x1a}},

		// mov    %fs:0xfffffffffffffff8,%r14
		{"MOVQ -0x8(FS), R14", []byte{0x64, 0x4c, 0x8b, 0x34, 0x25, 0xf8, 0xff, 0xff, 0xff}},
		// mov    %fs:0x0,%r14
		{"MOVQ (FS), R14", []byte{0x64, 0x4c, 0x8b, 0x34, 0x25, 0x00, 0x00, 0x00, 0x00}},

		// vpaddq %xmm1,%xmm2,%xmm3
		{"VPADDQ X1, X2, X3", []byte{0xc5, 0xe9, 0xd4, 0xd9}},

		{"RET", []byte{0xc3}},

		// ---- call, jmp - 0 address, PC relative ----
		{"CALL $0x5", []byte{0xe8, 0x00, 0x00, 0x00, 0x00}},
		{"JMP $0x2", []byte{0xeb, 0x00}},
	}

	for _, ts := range prog {
		inst, err := ArchAMD64.Decode(ts.code)
		assert.NoError(t, err, ts.exp)
		f := ArchAMD64.GoSyntax(inst, 0xff00000000000000, func(addr uint64) (name string, base uint64) {
			// fmt.Printf("-- check sym addr %d\n", addr)
			return "", 0
		}, nil)
		fmt.Println(f)
		assert.Equal(t, ts.exp, f.Asm, ts.exp)
	}

}

func TestRawBytesLiteralLE(t *testing.T) {
	type test struct {
		exp string
		b   []byte
	}
	tc := []test{
		{"QUAD $0x6f77206f6c6c6568; WORD $0x6c72; BYTE $0x64",
			[]byte("hello world")},
		{"LONG $0x3d8d48; WORD $0x0; BYTE $0x0",
			[]byte{0x48, 0x8d, 0x3d, 0x00, 0x00, 0x00, 0x00}},
		{"QUAD $0x0; BYTE $0x0",
			[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{"QUAD $0x201000000; BYTE $0x0",
			[]byte{0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00}},
		{"WORD $0x1", []byte{0x01, 0x00}},
		{"BYTE $0x0", []byte{0x00}},
		{"BYTE $0x1", []byte{0x01}},
	}
	for _, ts := range tc {
		actRaw := instEncodeRawBytes(binary.LittleEndian, ts.b)
		act := strings.Join(actRaw, "; ")
		assert.Equal(t, ts.exp, act)
	}
}
